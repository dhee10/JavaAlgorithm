# 배열
- 평균
    - 검색: O(n) 수를 찾을 때 제일 최선의 경우 한 번에 , 제일 최악의 경우 n번만에 찾는다 그러므로 평균 O(n)
    - 삽입: O(n) 중간에 수를 삽입하게 될 경우 삽입 되는 수의 뒷 수들을 다 밀어야한다. 최선 안밀기 , 최악 n개 밀기
    - 삭제: O(n) 중간에 수를 삭제하게 되면 뒷 수들을 끌어와야한다
    - !단 순서가 상관 없다면 삽입 / 삭제에서 수를 맨 뒤로 보내고 하면 되기 때문에 프로그래밍 시에 O(1)만에 가능 하지만
    알고리즘에서 말하는 일반적인 상황은 아님.


# 스택 -  제일 위에서 꺼내오기기 , 넣을때 제일 위에 넣기
- 평균
    - 검색: O(n) 스택은 자체로 검색이 힘들어 다 꺼낸 후 찾아야한다. (탐색)
    - 삽입: O(1) 스택의 삽입은 무조건 제일 위에 쌓아야 하므로 1
    - 삭제: O(1) 스택의 삭제는 무조건 제일 위 부터 삭제해야 하므로 1

# 큐 -  front와 back이 있어 값을 넣을때는 back에서 뺄 때는 front에서 뺀다. 선입선출
- 평균
    - 검색: O(n) 자체로 검색이 힘들어 다 꺼낸 후 찾아야한다.
    - 삽입: O(1) 삽입은 back에서 (제일뒤에, 삽입후 back의 위치가 움직임)
    - 삭제: O(1) 삭제는 제일 먼저 들어온거 부터 꺼낸다. front에서 (삭제 후 front가 움직임)
    - RingBuffer
    어느 순간 큐 배열에 마지막에 도달하면 삽입시에 다시 처음으로 돌아가 삽입해줘야한다. 이것을

# 연결리스트 - 각 노드가 데이터와 포인터를 가지고 있고 head부터 시작해 한 줄로 연결되어있는 방식으로
             데이터를 저장한다. 포인터는 다음 노드를 가르키며 다음 노드가 없다면 null , 있다면 다음 노드 주소를 값으로 가진다.
- 평균
    - 검색: O(n) 노드들의 배열을 순회해 찾아야 한다.
    - 삽입: O(1)
          1) 가장뒤에 삽입하는 경우: 마지막 노드의 포인터가 newNode를 가르키게 한다.
          2) node1과 node2중간에 노드를 삽입하는 경우: node1이 node2를 가르키는 연결을 끊고 newNode의 포인터는 node2를 , node1의 포인터는 new node를 가르키게한다.
    - 삭제: O(1)
          1) 가장 앞 노드를 삭제하는 경우: head가 두번째 노드를 가르키게 하고 가장 첫 노드를 free시킨다 (삭제한다)
          2) node1과 node3중간 노드 node2를 삭제하는 경우 : node2가 가르키던 node3은 node1이 가르키게 하고 삭제한다.

# 해시테이블
- 평균
    - 검색: O(1)
           한 배열에 하나의 데이터만 들어가 있다면 검색이 1이다.
           하지만 연결리스트로 배열에 여러 데이터가 있다면 최악의 경우 n이 걸린다.
    - 삽입: O(1)
          해시테이블의 삽입은 해시함수를 통해 나온 수를 배열의 수로 나눈 나머지 값으로 자리를 정한다.
          같은 나머지 값이 나온 데이터가 있다면 연결리스트로 연결해준다.
          ex) "haha" 데이터 -> 해시함수 -> 숫자 8이 나옴 8%7=1 --> [1]의 자리에 haha가 들어감
              "coco" 데이터 -> 해시함수 -> 숫자15가 나옴 15%7=1 --> [1]의 자리에 들어가야하는데 haha가 있음 haha의 포인터가 coco의 위치를 가르킴
    - 삭제: O(1)
- 최악
    - 검색: O(n)
    - 삽입: O(n)
    - 삭제: O(n)

---------------------

# 재귀함수
    public static int fibo(int number) {
        if( number <= 1) {
            return number;
        }

        retrun fibo(number -2) + fibo(number -1);
    }
    피보나치 수열로 이해하면 빠르다. (직접 트리 그려보기)
    fibo(3) 일 때를 그려보기

    - 장점
        가독성이 좋음
        코드가 짧음
        각 단계의 변수 상태가 자동 저장됨 (함수의 스택 프레임 덕분)
        코드 검증 쉬움
    - 단점
        재귀적 문제 분석/설계가 안 직관적
        맹목적 믿음 필요
        스택 오버플로 발생가능 (재귀함수 호출이 너무 깊은경우)

    - 스택 오버플로우가 없는 재귀
        꼬리재귀
            1) 함수코드 제일 마지막에서 다른 함수를 호출하는 경우
            2) 그 후에 실행하는 명령어가 없음
            3) 스택 프레임이 존재하는 이유는 함수에서 사용중인 변수 값을 유지하기 위해,
                타 함수 호출 후 반환되면 스택에 저장했던 값을 되돌려 사용하기 위해
            4) 꼬리 호출의 경우에는 타 함수로부터 반환 후 더 이상 연산이 없다.
            5) 이런 경우 컴파일러가 스택 프레임을 따로 안만드는 최적화를 하기도 한다.
                꼬리 호출 제거
                꼬리 호출 최적화




