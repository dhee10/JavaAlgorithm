
# 퀵 정렬 (코드 package com.javaAlgorithm.algorithm.focu;의 Quick_Sort 참고)
    1. 실무에서 가장 많이 사용
        - 일반적 / 범용적으로 가장 빠름
    2. 진정한 분할 정복 알고리듬
        - 모든 요소를 방문
        - 복잡도에 log가 있다는 것에서 눈치 챌 수 있음
    3. 어떤 값(pivot)을 기준으로 목록을 하위 목록으로 2개 나눔
        - 목록을 나누는 기준은 pivot 보다 작냐/크냐
        - 이 과정을 재귀적으로 반복
        - 재귀 단계가 깊어질 때 마다 새로운 pivot 값을 뽑음
    4. 안정성 보장되지 않음
    5. 시간 복잡도
       최악의 경우 O(n^2) - 기준 값이 변경 될 때마다 항상 오른쪽 끝에 오는 경우
       평균(n log n) - 기준 값이 변경 때 마다 가운데로 오는 경우
    6. 공간 복잡도
        - 재귀적으로 함수 호출
        - 실제 원본 배열을 고침 : O(1)
        - 함수 호출 깊이만큼 스택 메모리 사용 : O(log n) , 스택메모리라 할당/해재 매우빠름
        - 재귀 함수 두 번 호출해야함 (코드에서 quickSortRecursive 를 두번) : 꼬리 재귀를 사용하면 피하기 가능

    7. 예시 (index == i)
        7 2 5 1 3 8 7@ 4 9 6
        기준 값(pivot)을 가장 뒤에있는 6을 뽑고 이 보다 작은 값은 왼쪽 큰 값은 오른쪽으로 보낸다.
        좌 / 우를 정하고 우에 있는 수와 index에 있는 수를 비교해 index < 우 = 좌와 index값을 교환 후 좌를 index+1 자리로 옮긴다.
                                                         (좌=index 위치일 경우 셀프교환 후 좌를 한칸 밀기)
                                                         좌 > 우 = 아무것도 하지 않음
        우의 위치전까지 오면 좌와 우를 교환 후 우(기준값)은 최종위치가 된다.
        이 방법을 끊임 없이 반복.

        1회차(i=0) - 가장 좌 7 > 기준 값 6 이므로 그대로 둔다. (액션X)
            (i=1) - 2 < 6(기준값) 이므로 2는 오른쪽으로 한 칸 이동
                  2 7 5 1 3 8 7@ 4 9 6
            (i=2) - 5 < 6 이므로 5는 좌측으로 한 칸 이동
                  2 5 7 1 3 8 7@ 4 9 6
            (i=3) - 1 < 6 이므로 1은 좌측으로 한 칸 이동
                  2 5 1 7 3 8 7@ 4 9 6
            (i=4) - 3 < 6 이므로 3은 좌측으로 한 칸 이동
                  2 5 1 3 7 8 7@ 4 9 6
            (i=5) - 8 > 6 이므로 그대로 둔다
                  2 5 1 3 7 8 7@ 4 9 6
            (i=6) - 7 > 6 이므로 그대로 둔다
                  2 5 1 3 7 8 7@ 4 9 6
            (i=7) - 4 > 6 이므로 4와 7 교환 후 좌를 오른쪽으로 한 칸 민다. (이 때 부터 좌의 기준은 7이 아닌 8)
                  2 5 1 3 4 8 7@ 7 9 6 (7의 위치가 바뀜 안정성 보장X)
            (i=8) - 9 < 6 이므로 그대로 둔다.
                  2 5 1 3 4 8 7@ 7 9 6
            이 때 좌 8을 기준으로 왼쪽은 다 6보다 작은거 오른쪽은 6보다 큰 것이 존재 8과 6을 교환하면
            6의 최종위치가 된다.
                  2 5 1 3 4 6 7@ 7 9 8

            ... 이 후로 왼쪽 2 5 1 3 4 과 오른쪽 7@ 7 9 8을 각각 정렬하면 끝


