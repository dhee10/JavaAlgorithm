# 버블 정렬
    1. 이웃 요소 둘을 비교해 올바른 순서로 고치는 과정을 반복
    2. 한 번 목록을 순회할 때 마다 가장 큰 값이 제일 위로 올라감
        예시) 5313462
        를 전체 훑는 횟 수 6회 (n-1회, n은 요소순)
        가장 많이 방문한 수 n-1번
        가장 적게 방문한 수 1번
        평균 요소 수는? (n-1+1) /2 = n/2
        즉 시간 복잡도 O(n^2) (대충 2중 for문 - O(n^2))

        공간 복잡도는 새로 만드는 부분이 없어서 O(1)

        안정성은 정렬 후에 순서가 유지되므로 안정하다.

    public static void bubbleSort(int[] nums) {
        for (int i = 0; i < nums.length - 1; i++) { //목록을 총 훑는 수
            for (int j = 0; j < nums.length - i -1; j++) { //한 번 훑을 때마다 방문하는 요소 수가 1씩 줆 (한 번 훑을 때마다 고정값이 생기므로)
                if(nums[j] > nums[j+1]){
                    int temp = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = tmep;

                }
            }
        }
    }
    3. 안정성 보장
